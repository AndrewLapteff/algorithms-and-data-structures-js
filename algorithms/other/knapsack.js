// //www.youtube.com/watch?v=wcjqBf2qRe0

// function knapsackUnlimitedCapacity(values, weights, capacity) {
//   const n = values.length // Кількість доступних предметів
//   const dp = new Array(capacity + 1).fill(0) // Масив для збереження максимальної вартості для кожної вмістимості

//   // Проходимось по всіх можливих вмістимостях рюкзака
//   for (let w = 0; w <= capacity; w++) {
//     // Проходимось по всіх предметах
//     for (let i = 0; i < n; i++) {
//       // Перевіряємо, чи можна додати поточний предмет у рюкзак з вмістимістю 'w'
//       if (weights[i] <= w) {
//         // Оновлюємо максимальну вартість, вибираючи максимум між поточим значенням та значенням,
//         // яке можна отримати, вибравши поточний предмет і зменшивши вмістимість на вагу предмета
//         dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i])
//         // Рядок dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]) в коді вище використовується для оновлення значення максимальної вартості для конкретної вмістимості рюкзака.
//         // Ось розподіл кожного компонента в цьому виразі:
//         // dp[w]: Це є поточне найкраще (максимальне) значення вартості для вмістимості w рюкзака. dp - це масив, в якому зберігаються результати для різних вмістимостей рюкзака.
//         // Math.max(dp[w], ...): Ця частина визначає максимальне значення між поточним найкращим значенням dp[w] і новим значенням, яке можливо отримати, вибравши поточний предмет i і зменшивши вмістимість рюкзака на вагу предмета weights[i]. Ідея полягає в тому, що ми перевіряємо, чи буде вигідніше додати поточний предмет до рюкзака чи залишити його.
//         // dp[w - weights[i]] + values[i]: Ця частина обчислює, яку вартість ми отримаємо, додавши поточний предмет i до рюкзака. dp[w - weights[i]] представляє найкращу вартість, яку можна було б отримати до додавання поточного предмета, і ми додаємо до неї вартість values[i] поточного предмета, щоб знайти нову вартість.
//         // Отже, вираз dp[w] = Math.max(dp[w], dp[w - weights[i]] + values[i]) допомагає нам визначити, чи варто додавати поточний предмет до рюкзака для досягнення максимальної вартості. Ми обираємо максимум між поточним найкращим значенням dp[w] і новим значенням, яке отримаємо, якщо додамо поточний предмет до рюкзака.
//       }
//     }
//   }

//   return dp[capacity] // Повертаємо максимальну вартість рюкзака
// }

// const values = [40, 100, 120]
// const weights = [10, 20, 30]
// const capacity = 50

// const maxTotalValue = knapsackUnlimitedCapacity(values, weights, capacity)
// console.log('Максимальна вартість: ' + maxTotalValue)
