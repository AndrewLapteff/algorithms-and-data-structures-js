// Time: O(n+k) де n - довжина массиву, k - максимальне число массиву
// Space: O(n+k) де n - довжина массиву, k - максимальне число массиву
// Тому, цей алгоритм поганий якщо числа мають сильно розкидані одне від одного

const countingSort = (input) => {
  // ініціалізуємо массив в якому будемо зберігати майбутні індекси
  // довжина має дорівнювати максимальному елементу в вхідному массиві
  const counts = Array(Math.max(...input)).fill(0)
  const output = []
  // виділяємо елементи котрі є в вхідному массиві
  for (elm of input) {
    counts[elm] = 1
  }
  // проходимось по массиву з формулою n = n + (n - 1) для генерації індексів на місці значеннь в массиві counts 
  for (let i = 1; i < counts.length; i++) {
    counts[i] = counts[i] + counts[i - 1]
  }

  for (let i = 0; i < input.length; i++) {
    // arr[i] - отримуємо значення з массиву
    // counts[arr[i]] - 1  - отримуємо його індекс корректний індекс
    // output[counts[arr[i]] - 1] = arr[i]  - записуємо під його індексом те число яке розглядали
    output[counts[input[i]] - 1] = input[i]
    // на випадок якщо ми матимемо два одинакових числа в input массиві
    // таким чином друге число отримає індекс - 1 від першого
    counts[input[i]]--
  }
  return output
}

console.time()
countingSort([4, 2, 5, 21, 7, 8, 19]) // ~ 0.145ms
console.timeEnd()
